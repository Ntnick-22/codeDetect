name: CI/CD - Docker Build & Blue/Green Deploy

# When to run this workflow
on:
  push:
    branches:
      - main  # Run on every push to main branch
  workflow_dispatch:  # Allow manual trigger from GitHub UI
    inputs:
      docker_tag:
        description: 'Docker image tag (e.g., v1.0, v1.1)'
        required: false
        default: 'latest'
      deploy_environment:
        description: 'Deploy to blue or green environment'
        required: false
        default: 'blue'
        type: choice
        options:
          - blue
          - green

# Environment variables available to all jobs
env:
  DOCKER_USERNAME: nyeinthunaing
  DOCKER_IMAGE: nyeinthunaing/codedetect
  AWS_REGION: eu-west-1

jobs:
  # =================================================================
  # JOB 1: TEST & QUALITY CHECKS
  # =================================================================
  test:
    name: Run Tests & Quality Checks
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install pytest pytest-cov pytest-flask  # Add testing dependencies

      - name: Run Unit Tests
        run: |
          echo "=== Running Unit Tests ==="
          pytest tests/ -v --tb=short --cov=backend --cov-report=term-missing --cov-report=html
          echo ""
          echo "All tests passed"

      - name: Run Pylint (Code Quality - ENFORCED)
        run: |
          echo "=== Running Pylint Code Quality Check ==="
          echo "This step will FAIL if code quality is below threshold"
          echo ""

          # Run Pylint and capture output
          pylint backend/app.py --output-format=colorized --score=yes || PYLINT_EXIT=$?

          # Pylint exit codes:
          # 0 = no issues
          # 1 = fatal message issued
          # 2 = error message issued
          # 4 = warning message issued
          # 8 = refactor message issued
          # 16 = convention message issued
          # 32 = usage error

          # Fail on fatal (1) or error (2) or usage error (32)
          if [ "${PYLINT_EXIT:-0}" -eq 1 ] || [ "${PYLINT_EXIT:-0}" -eq 2 ] || [ "${PYLINT_EXIT:-0}" -eq 32 ]; then
            echo ""
            echo "FAILED: Critical Pylint issues found (exit code: ${PYLINT_EXIT})"
            echo "Fix errors before pushing to main branch"
            exit 1
          fi

          echo ""
          echo "Pylint check passed (warnings allowed, errors blocked)"

      - name: Run Bandit (Security Check - ENFORCED)
        run: |
          echo "=== Running Bandit Security Scan ==="
          echo "This step will FAIL if HIGH severity security issues are found"
          echo ""

          pip install pbr  # Install missing dependency

          # Run Bandit and generate JSON report
          bandit -r backend/ -f json -o bandit-report.json || true

          # Also show human-readable output
          bandit -r backend/ -f screen || true

          # Check for HIGH severity issues
          if grep -q '"issue_severity": "HIGH"' bandit-report.json; then
            echo ""
            echo "FAILED: HIGH severity security issues found!"
            echo "Review bandit-report.json for details"
            echo ""
            echo "HIGH severity issues found:"
            grep -A 5 '"issue_severity": "HIGH"' bandit-report.json | head -20
            exit 1
          fi

          # Check for MEDIUM severity with HIGH confidence (also critical)
          MEDIUM_HIGH_COUNT=$(grep -c '"issue_severity": "MEDIUM".*"issue_confidence": "HIGH"' bandit-report.json || true)
          if [ "$MEDIUM_HIGH_COUNT" -gt 3 ]; then
            echo ""
            echo "WARNING: Found $MEDIUM_HIGH_COUNT MEDIUM severity issues with HIGH confidence"
            echo "Consider fixing these before deployment"
          fi

          echo ""
          echo "Bandit security scan passed (no HIGH severity issues)"

      - name: Test Docker Build
        run: |
          echo "=== Testing Docker Build ==="
          docker build -t codedetect-test:${{ github.sha }} .
          echo "Docker build successful!"

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-reports
          path: |
            bandit-report.json
            htmlcov/
            .coverage
          retention-days: 30

  # =================================================================
  # JOB 2: BUILD & PUSH DOCKER IMAGE
  # =================================================================
  build-docker:
    name: Build & Push Docker Image
    needs: test
    runs-on: ubuntu-latest

    outputs:
      docker_tag: ${{ steps.generate_tag.outputs.tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate Docker Tag
        id: generate_tag
        run: |
          # If manual trigger with custom tag, use that
          if [ "${{ github.event.inputs.docker_tag }}" != "" ]; then
            TAG="${{ github.event.inputs.docker_tag }}"
          else
            # Auto-generate tag from commit SHA (first 7 chars)
            TAG="v$(date +%Y%m%d)-${GITHUB_SHA::7}"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated Docker tag: $TAG"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:${{ steps.generate_tag.outputs.tag }}
            ${{ env.DOCKER_IMAGE }}:latest
          cache-from: type=registry,ref=${{ env.DOCKER_IMAGE }}:latest
          cache-to: type=inline

      - name: Image Summary
        run: |
          echo "Docker image built and pushed successfully!"
          echo ""
          echo "Image: ${{ env.DOCKER_IMAGE }}:${{ steps.generate_tag.outputs.tag }}"
          echo "Latest: ${{ env.DOCKER_IMAGE }}:latest"
          echo ""
          echo "To pull this image:"
          echo "  docker pull ${{ env.DOCKER_IMAGE }}:${{ steps.generate_tag.outputs.tag }}"

  # =================================================================
  # JOB 3: BLUE/GREEN DEPLOYMENT TO AWS
  # =================================================================
  deploy:
    name: Deploy to AWS (Blue/Green)
    needs: build-docker
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        run: |
          cd terraform
          terraform init

      - name: Determine Target Environment
        id: target_env
        run: |
          cd terraform

          # If manual trigger, use specified environment
          if [ "${{ github.event.inputs.deploy_environment }}" != "" ]; then
            TARGET="${{ github.event.inputs.deploy_environment }}"
          else
            # Auto-determine: Get current active environment, deploy to the other one
            CURRENT=$(terraform output -raw active_environment 2>/dev/null || echo "green")
            echo "Current active environment: $CURRENT"
            if [ "$CURRENT" = "blue" ]; then
              TARGET="green"
            else
              TARGET="blue"
            fi
          fi

          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "Target environment: $TARGET"

      - name: Blue/Green Deployment
        run: |
          cd terraform

          DOCKER_TAG="${{ needs.build-docker.outputs.docker_tag }}"
          TARGET_ENV="${{ steps.target_env.outputs.target }}"

          echo "=== BLUE/GREEN DEPLOYMENT ==="
          echo "Docker Tag: $DOCKER_TAG"
          echo "Target Environment: $TARGET_ENV"
          echo ""

          # Plan the deployment
          echo "Running Terraform plan..."
          if ! terraform plan \
            -var="active_environment=$TARGET_ENV" \
            -var="docker_tag=$DOCKER_TAG" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -var="notification_email=${{ secrets.NOTIFICATION_EMAIL }}" \
            -out=tfplan; then
            echo "Terraform plan failed!"
            echo "Showing detailed error logs..."
            terraform plan \
              -var="active_environment=$TARGET_ENV" \
              -var="docker_tag=$DOCKER_TAG" \
              -var="db_password=${{ secrets.DB_PASSWORD }}" \
              -var="notification_email=${{ secrets.NOTIFICATION_EMAIL }}" \
              -no-color
            exit 1
          fi

          # Apply the deployment
          echo ""
          echo "Applying Terraform changes..."
          if ! terraform apply -auto-approve tfplan; then
            echo "Terraform apply failed!"
            echo "Showing Terraform state..."
            terraform show
            exit 1
          fi

          echo ""
          echo "Terraform apply completed!"

      - name: Wait for Instances to be Healthy
        run: |
          TARGET_ENV="${{ steps.target_env.outputs.target }}"
          ASG_NAME="codedetect-prod-${TARGET_ENV}-asg"

          echo "=== Waiting for instances in $ASG_NAME to be healthy ==="
          echo "This takes ~5-10 minutes (instance boot + Docker pull + health checks)"

          for i in {1..30}; do
            # Get desired capacity
            DESIRED=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "$ASG_NAME" \
              --query 'AutoScalingGroups[0].DesiredCapacity' \
              --output text 2>/dev/null || echo "0")

            # Get healthy instance count
            HEALTHY=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "$ASG_NAME" \
              --query 'AutoScalingGroups[0].Instances[?HealthStatus==`Healthy`]|length(@)' \
              --output text 2>/dev/null || echo "0")

            echo "[$i/30] Healthy instances: $HEALTHY / $DESIRED"

            if [ "$HEALTHY" -ge "$DESIRED" ] && [ "$DESIRED" -gt "0" ]; then
              echo "All instances are healthy!"
              break
            fi

            sleep 20
          done

      - name: Health Check via Load Balancer
        run: |
          echo "=== Running health check ==="

          # Get ALB DNS name from Terraform output
          cd terraform
          ALB_DNS=$(terraform output -raw load_balancer_dns)
          echo "ALB DNS: $ALB_DNS"

          sleep 15

          # Try HTTP health check via ALB DNS (since enable_dns=false)
          response=$(curl -s -o /dev/null -w "%{http_code}" http://$ALB_DNS/api/health || echo "000")

          if [ "$response" = "200" ]; then
            echo "Deployment successful!"
            echo ""
            echo "Application URL: http://$ALB_DNS"
            echo "Docker Tag: ${{ needs.build-docker.outputs.docker_tag }}"
            echo "Active Environment: ${{ steps.target_env.outputs.target }}"
            echo ""
            echo "App Info:"
            curl -s http://$ALB_DNS/api/info | head -10
          else
            echo "WARNING: Health check response: $response"
            echo "Application might still be starting..."

            # Retry a few times
            for i in {1..5}; do
              echo "Retry $i/5..."
              sleep 15
              response=$(curl -s -o /dev/null -w "%{http_code}" http://$ALB_DNS/api/health || echo "000")
              if [ "$response" = "200" ]; then
                echo "Deployment successful!"
                echo ""
                echo "Application URL: http://$ALB_DNS"
                exit 0
              fi
            done

            echo "FAILED: Health check failed after retries. Please check AWS Console."
            echo "Check ALB target health: https://console.aws.amazon.com/ec2/v2/home?region=eu-west-1#TargetGroups:"
            exit 1
          fi

      - name: Deployment Summary
        if: always()
        run: |
          cd terraform
          ALB_DNS=$(terraform output -raw load_balancer_dns 2>/dev/null || echo "unknown")

          echo ""
          echo "=============================================="
          echo "DEPLOYMENT SUMMARY"
          echo "=============================================="
          echo "Docker Image: ${{ env.DOCKER_IMAGE }}:${{ needs.build-docker.outputs.docker_tag }}"
          echo "Deployed to: ${{ steps.target_env.outputs.target }} environment"
          echo "URL: http://$ALB_DNS"
          echo "=============================================="
          echo ""
          echo "Next steps:"
          echo "  - Test the application: curl http://$ALB_DNS/api/health"
          echo "  - Monitor CloudWatch metrics"
          echo "  - If issues, rollback with: terraform apply -var='active_environment=<old-env>'"
